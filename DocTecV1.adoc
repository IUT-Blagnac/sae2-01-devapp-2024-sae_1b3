= Documentation Technique

:toc: right
:toclevels: 4

== Fonctionalité Ajouter Compte

=== Introduction

Cette documentation couvre les modifications apportées le 22/05/2024 concernant la création de nouveaux comptes dans l'application de gestion bancaire. Les changements incluent la mise à jour de la méthode `creerNouveauCompte` dans la classe `ComptesManagement`, ainsi que l'ajout de nouvelles méthodes `insertCompte` et `getTousLesComptes` dans la classe `Access_BD_CompteCourant`.

=== Modifications dans `ComptesManagement`

==== Méthode `creerNouveauCompte`

[source,java]
----
public CompteCourant creerNouveauCompte() {
    CompteCourant compte;
    CompteEditorPane cep = new CompteEditorPane(this.cmStage, this.dailyBankState);

    // Récupérer la liste de tous les comptes existants
    ArrayList<CompteCourant> tousLesComptes = new ArrayList<>();
    try {
        Access_BD_CompteCourant acc = new Access_BD_CompteCourant();
        tousLesComptes = acc.getTousLesComptes();
    } catch (DatabaseConnexionException e) {
        ExceptionDialog ed = new ExceptionDialog(this.cmStage, this.dailyBankState, e);
        ed.doExceptionDialog();
        this.cmStage.close();
        return null;
    } catch (ApplicationException ae) {
        ExceptionDialog ed = new ExceptionDialog(this.cmStage, this.dailyBankState, ae);
        ed.doExceptionDialog();
        return null;
    }

    // Trouver le numéro de compte le plus élevé parmi tous les comptes
    int dernierNumeroCompte = 0;
    for (CompteCourant c : tousLesComptes) {
        if (c.idNumCompte > dernierNumeroCompte) {
            dernierNumeroCompte = c.idNumCompte;
        }
    }

    // Incrémenter pour obtenir le nouveau numéro de compte
    int nouveauNumeroCompte = dernierNumeroCompte + 1;
    System.out.println("Nouveau numéro de compte : " + nouveauNumeroCompte);

    // Créer le nouveau compte avec le numéro de compte correct
    compte = cep.doCompteEditorDialog(this.clientDesComptes, null, EditionMode.CREATION);
    if (compte != null) {
        compte.idNumCompte = nouveauNumeroCompte;
        System.out.println("Compte à insérer : " + compte.idNumCompte);
        try {
            Access_BD_CompteCourant acc = new Access_BD_CompteCourant();
            acc.insertCompte(compte); // Enregistre le compte dans la base de données
            AlertUtilities.showAlert(this.cmStage, "Création réussie", "Compte créé",
                    "Le nouveau compte a été créé avec succès", AlertType.INFORMATION);
        } catch (DatabaseConnexionException e) {
            ExceptionDialog ed = new ExceptionDialog(this.cmStage, this.dailyBankState, e);
            ed.doExceptionDialog();
            this.cmStage.close();
        } catch (ApplicationException ae) {
            ExceptionDialog ed = new ExceptionDialog(this.cmStage, this.dailyBankState, ae);
            ed.doExceptionDialog();
        }
    }
    return compte;
}
----
 Description des étapes de la méthode creerNouveauCompte :

    Initialisation et ouverture de l'éditeur de compte :
        La méthode commence par initialiser un objet CompteEditorPane pour afficher la fenêtre de dialogue de création de compte.

    Récupération de tous les comptes existants :
        La méthode appelle getTousLesComptes pour obtenir la liste de tous les comptes courants existants.
        Si une exception DatabaseConnexionException ou ApplicationException est levée, un dialogue d'exception est affiché et la méthode retourne null.

    Détermination du nouveau numéro de compte :
        La méthode parcourt tous les comptes existants pour trouver le numéro de compte le plus élevé.
        Ensuite, elle incrémente ce numéro pour obtenir le nouveau numéro de compte.

    Création du nouveau compte :
        L'utilisateur entre les détails du nouveau compte via l'éditeur de compte.
        Si un compte valide est retourné, son numéro de compte est mis à jour avec le nouveau numéro calculé.

    Insertion du nouveau compte dans la base de données :
        La méthode insertCompte est appelée pour enregistrer le nouveau compte dans la base de données.
        En cas de succès, une alerte de confirmation est affichée. En cas d'erreur, un dialogue d'exception est affiché.


=== Modifications dans `Access_BD_CompteCourant`

==== Méthode `insertCompte`

[source,java]
----
public void insertCompte(CompteCourant compte) throws DataAccessException, DatabaseConnexionException {
    try {
        Connection con = LogToDatabase.getConnexion();
        String query = "INSERT INTO CompteCourant (idNumCompte, debitAutorise, solde, estCloture, idNumCli) VALUES (?, ?, ?, ?, ?)";

        PreparedStatement pst = con.prepareStatement(query);
        pst.setInt(1, compte.idNumCompte);
        pst.setInt(2, compte.debitAutorise);
        pst.setDouble(3, compte.solde);
        pst.setString(4, compte.estCloture);
        pst.setInt(5, compte.idNumCli);

        pst.executeUpdate();
        pst.close();
        con.commit();
    } catch (SQLException e) {
        throw new DataAccessException(Table.CompteCourant, Order.INSERT, "Erreur lors de l'insertion du compte", e);
    }
}
----

Description de la méthode insertCompte :

    Connexion à la base de données :
        La méthode établit une connexion avec la base de données via LogToDatabase.getConnexion().

    Préparation et exécution de la requête SQL :
        Une requête SQL INSERT est préparée pour insérer un nouveau compte dans la table CompteCourant.
        Les valeurs des colonnes sont définies en utilisant les méthodes setInt, setDouble, et setString du PreparedStatement.

    Gestion des erreurs :
        Si une exception SQL est levée, une DataAccessException est lancée avec des détails sur l'erreur.

==== Méthode `getTousLesComptes`

[source,java]
----
public ArrayList<CompteCourant> getTousLesComptes() throws DataAccessException, DatabaseConnexionException {
    ArrayList<CompteCourant> alResult = new ArrayList<>();

    try {
        Connection con = LogToDatabase.getConnexion();
        String query = "SELECT * FROM CompteCourant ORDER BY idNumCompte";

        PreparedStatement pst = con.prepareStatement(query);
        ResultSet rs = pst.executeQuery();
        while (rs.next()) {
            int idNumCompte = rs.getInt("idNumCompte");
            int debitAutorise = rs.getInt("debitAutorise");
            double solde = rs.getDouble("solde");
            String estCloture =

[source,java]

rs.getString("estCloture");
int idNumCli = rs.getInt("idNumCli");

vbnet

        alResult.add(new CompteCourant(idNumCompte, debitAutorise, solde, estCloture, idNumCli));
    }
    rs.close();
    pst.close();
} catch (SQLException e) {
    throw new DataAccessException(Table.CompteCourant, Order.SELECT, "Erreur accès", e);
}

return alResult;

}
----

 Description de la méthode getTousLesComptes :

    Connexion à la base de données :
        La méthode établit une connexion avec la base de données via LogToDatabase.getConnexion().

    Préparation et exécution de la requête SQL :
        Une requête SQL SELECT est préparée pour récupérer tous les comptes courants ordonnés par idNumCompte.
        Les résultats de la requête sont traités ligne par ligne pour créer des objets CompteCourant et les ajouter à une liste.

    Gestion des erreurs :
        Si une exception SQL est levée, une DataAccessException est lancée avec des détails sur l'erreur.

=== Conclusion

Ces modifications permettent d'assurer la création de nouveaux comptes courants avec un numéro de compte unique, en récupérant d'abord tous les comptes existants pour déterminer le nouveau numéro de compte. Les méthodes ajoutées dans Access_BD_CompteCourant garantissent l'insertion correcte des nouveaux comptes dans la base de données et la récupération de tous les comptes existants.


== Ajouter Fonction Read Chef d'agence

== Introduction

Cette documentation technique couvre les modifications apportées le 22/05/2024 concernant la gestion des employés dans l'application de gestion bancaire. Les changements incluent l'ajout de getters dans la classe `Employe`, la modification de la méthode `doEmployeOption` dans `DailyBankMainFrameController`, la création d'un nouveau contrôleur pour gérer la liste des employés, et la mise en place d'un fichier FXML associé.

== Modifications dans `Employe`

=== Ajout des Getters

[source,java]
----
public class Employe {
    private int idEmploye;
    private String nom;
    private String prenom;
    private String droitsAccess;
    private String login;

    public int getIdEmploye() {
        return idEmploye;
    }

    public String getNom() {
        return nom;
    }

    public String getPrenom() {
        return prenom;
    }

    public String getDroitsAccess() {
        return droitsAccess;
    }

    public String getLogin() {
        return login;
    }
}
----

Description des modifications dans Employe :

    Ajout des méthodes getter :
        Les getters pour les attributs idEmploye, nom, prenom, droitsAccess, et login ont été ajoutés pour permettre l’accès sécurisé à ces propriétés.

== Modifications dans `DailyBankMainFrameController`

=== Méthode `doEmployeOption`

[source,java]
----
@FXML
private void doEmployeOption() {
    try {
        FXMLLoader loader = new FXMLLoader(getClass().getResource("/application/view/employesmanagement.fxml"));
        VBox employeListPane = loader.load();
        Scene scene = new Scene(employeListPane);
        Stage stage = new Stage();
        stage.setScene(scene);
        stage.setTitle("Liste des Employés");
        stage.show();
    } catch (IOException e) {
        e.printStackTrace();
        AlertUtilities.showAlert(this.containingStage, "Erreur", null, "Impossible de charger la vue des employés.", AlertType.ERROR);
    }
}
----

Description des modifications dans doEmployeOption :

    Vérification des droits d’accès :
        La méthode vérifie si l’utilisateur actuel est un chef d’agence en utilisant this.dailyBankState.isChefDAgence().
        Si c’est le cas, un objet EmployeManagement est créé et la méthode doEmployeManagementDialog est appelée.
        Sinon, une alerte d’erreur est affichée indiquant que l’accès est refusé.

=== Création du Contrôleur `EmployeController`

==== Code du Contrôleur

[source,java]
----
package application.view;

import javafx.collections.FXCollections;
import javafx.collections.ObservableList;
import javafx.fxml.FXML;
import javafx.scene.control.TableColumn;
import javafx.scene.control.TableView;
import javafx.scene.control.cell.PropertyValueFactory;
import model.data.Employe;
import model.orm.Access_BD_Employe;
import model.orm.exception.DataAccessException;
import model.orm.exception.DatabaseConnexionException;
import java.util.List;

public class EmployeController {

    @FXML
    private TableView<Employe> employeTable;

    @FXML
    private TableColumn<Employe, Integer> idColumn;

    @FXML
    private TableColumn<Employe, String> nomColumn;

    @FXML
    private TableColumn<Employe, String> prenomColumn;

    @FXML
    private TableColumn<Employe, String> droitsAccessColumn;

    @FXML
    private TableColumn<Employe, String> loginColumn;

    private ObservableList<Employe> employeData = FXCollections.observableArrayList();

    @FXML
    private void initialize() {
        System.out.println("Initializing EmployeController");
        
        // Initialiser la table avec les colonnes
        idColumn.setCellValueFactory(new PropertyValueFactory<>("idEmploye"));
        nomColumn.setCellValueFactory(new PropertyValueFactory<>("nom"));
        prenomColumn.setCellValueFactory(new PropertyValueFactory<>("prenom"));
        droitsAccessColumn.setCellValueFactory(new PropertyValueFactory<>("droitsAccess"));
        loginColumn.setCellValueFactory(new PropertyValueFactory<>("login"));
    
        // Mettre la liste d'employés sur la table pour l'affichage
        employeTable.setItems(employeData);
    }

    public void setEmployeData(ObservableList<Employe> employeData) {
        this.employeData = employeData;
        employeTable.setItems(employeData);
    }

    @FXML
    private void loadEmployes() {
        Access_BD_Employe accessBDEmploye = new Access_BD_Employe();
        try {
            List<Employe> employes = accessBDEmploye.getAllEmployes();
            System.out.println("Loaded employees: " + employes.size()); // Ligne de débogage
            employeData.setAll(employes);
        } catch (DataAccessException | DatabaseConnexionException e) {
            e.printStackTrace();
        }
    }
}
----

Description du EmployeManagementController :

    Attributs FXML :
        Les éléments de la table et les colonnes sont définis avec les annotations @FXML.

    Méthode initContext :
        Initialisation du contexte avec les paramètres nécessaires.
        Chargement des données des employés.

    Méthode initialize :
        Configuration des colonnes de la table pour afficher les attributs des employés.

    Méthode loadEmployeData :
        Récupération des données des employés via Access_BD_Employe.
        Chargement des données dans la table.

=== Vue FXML pour `EmployeController`

==== Code FXML

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Button?>
<?import javafx.scene.control.TableColumn?>
<?import javafx.scene.control.TableView?>
<?import javafx.scene.layout.VBox?>

<VBox spacing="10" alignment="CENTER" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="application.view.EmployeController">
    <TableView fx:id="employeTable">
        <columns>
            <TableColumn fx:id="idColumn" text="ID" />
            <TableColumn fx:id="nomColumn" text="Nom" />
            <TableColumn fx:id="prenomColumn" text="Prénom" />
            <TableColumn fx:id="droitsAccessColumn" text="Droits d'Accès" />
            <TableColumn fx:id="loginColumn" text="Login" />
        </columns>
    </TableView>
    <Button text="Charger Employés" onAction="#loadEmployes"/>
</VBox>
----

Description du fichier FXML :

    Structure de base :
        Utilisation d’un AnchorPane comme conteneur principal.
        Inclusion d’une TableView avec des TableColumn pour afficher les attributs des employés.

=== Conclusion

Les modifications permettent de charger et afficher la liste des employés rattachés à une agence dans une nouvelle fenêtre. Les getters ajoutés à la classe `Employe` facilitent l'accès aux propriétés des employés. La méthode `doEmployeOption` dans `DailyBankMainFrameController` permet de charger la nouvelle vue FXML `employesmanagement.fxml`, et le contrôleur `EmployeController` gère l'affichage des données des employés dans une table.

== Fonctionalité Create employé

=== Introduction

Cette documentation technique couvre les modifications apportées pour permettre la création d'un nouvel employé dans l'application de gestion bancaire. Les changements incluent l'ajout d'un nouveau contrôleur pour gérer la création d'employés, la création d'un fichier FXML associé, et l'ajout de différentes fonctions dans la classe `Access_BD_Employe` pour interagir avec la base de données.

=== Création d'un Nouveau Contrôleur

==== Code du Contrôleur `AddEmployeController`

[source,java]
----
package application.view;

import javafx.fxml.FXML;
import javafx.scene.control.Alert;
import javafx.scene.control.RadioButton;
import javafx.scene.control.TextField;
import javafx.stage.Stage;
import model.data.Employe;
import model.orm.Access_BD_Employe;
import model.orm.exception.DataAccessException;
import model.orm.exception.DatabaseConnexionException;

public class AddEmployeController {

    @FXML
    private TextField nomField;

    @FXML
    private TextField prenomField;

    @FXML
    private RadioButton adminRadioButton;

    @FXML
    private RadioButton userRadioButton;

    @FXML
    private TextField loginField;

    @FXML
    private TextField motPasseField;

    @FXML
    private TextField idAgField;

    private Stage dialogStage;
    private boolean okClicked = false;

    public void setDialogStage(Stage dialogStage) {
        this.dialogStage = dialogStage;
    }

    public boolean isOkClicked() {
        return okClicked;
    }

    @FXML
    private void handleAddEmploye() {
        if (isInputValid()) {
            String login = loginField.getText();
    
            try {
                Access_BD_Employe accessBDEmploye = new Access_BD_Employe();
                Employe existingEmploye = accessBDEmploye.getEmployeByLogin(login);
                
                if (existingEmploye != null) {
                    showAlert(Alert.AlertType.ERROR, "Erreur d'ajout", "Ce login est déjà utilisé par un autre employé.");
                    return;
                }
            } catch (DataAccessException | DatabaseConnexionException e) {
                showAlert(Alert.AlertType.ERROR, "Erreur de base de données", "Une erreur s'est produite lors de la vérification du login.");
                e.printStackTrace();
                return;
            }
    
            String nom = nomField.getText();
            String prenom = prenomField.getText();
            String droitsAccess;
            if (userRadioButton.isSelected()) {
                droitsAccess = "guichetier";
            } else if (adminRadioButton.isSelected()) {
                droitsAccess = "chefAgence";
            } else {
                droitsAccess = "guichetier";
            }
    
            String motPasse = motPasseField.getText();
            int idAg = Integer.parseInt(idAgField.getText());
    
            Employe newEmploye = new Employe(0, nom, prenom, droitsAccess, login, motPasse, idAg);
    
            try {
                Access_BD_Employe accessBDEmploye = new Access_BD_Employe();
                accessBDEmploye.addEmploye(newEmploye);
                okClicked = true;
                dialogStage.close();
            } catch (DataAccessException | DatabaseConnexionException e) {
                showAlert(Alert.AlertType.ERROR, "Erreur de base de données", "Une erreur s'est produite lors de l'ajout de l'employé.");
                e.printStackTrace();
            }
        }
    }

    @FXML
    private void handleCancel() {
        dialogStage.close();
    }

    private boolean isInputValid() {
        String errorMessage = "";

        if (nomField.getText() == null || nomField.getText().isEmpty()) {
            errorMessage += "Nom invalide!\n";
        }
        if (prenomField.getText() == null || prenomField.getText().isEmpty()) {
            errorMessage += "Prenom invalide!\n";
        }
        if (loginField.getText() == null || loginField.getText().isEmpty()) {
            errorMessage += "Login invalide!\n";
        }
        if (motPasseField.getText() == null || motPasseField.getText().isEmpty()) {
            errorMessage += "Mot de passe invalide!\n";
        }
        if (idAgField.getText() == null || idAgField.getText().isEmpty()) {
            errorMessage += "Numéro d'agence invalide!\n";
        } else {
            try {
                Integer.parseInt(idAgField.getText());
            } catch (NumberFormatException e) {
                errorMessage += "Numéro d'agence doit être un entier!\n";
            }
        }

        if (errorMessage.isEmpty()) {
            return true;
        } else {
            showAlert(Alert.AlertType.ERROR, "Champs invalides", errorMessage);
            return false;
        }
    }

    private void showAlert(Alert.AlertType alertType, String title, String message) {
        Alert alert = new Alert(alertType);
        alert.setTitle(title);
        alert.setContentText(message);
        alert.showAndWait();
    }
}
----

==== Description des Méthodes

- `setDialogStage(Stage dialogStage)`: Configure la fenêtre de dialogue.
- `isOkClicked()`: Retourne `true` si l'utilisateur a confirmé l'ajout.
- `handleAddEmploye()`: Gère l'ajout d'un nouvel employé après validation des champs de saisie. Vérifie si le login est déjà utilisé et affiche des alertes en cas d'erreurs.
- `handleCancel()`: Ferme la fenêtre de dialogue.
- `isInputValid()`: Valide les champs de saisie et affiche des messages d'erreur si nécessaire.
- `showAlert(Alert.AlertType alertType, String title, String message)`: Affiche une alerte avec le type, le titre et le message spécifiés.

=== Vue FXML pour `AddEmployeController`

==== Code FXML

[source,xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>
<?import javafx.scene.control.RadioButton?>
<?import javafx.scene.control.TextField?>
<?import javafx.scene.control.ToggleGroup?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.layout.VBox?>

<VBox spacing="10" alignment="CENTER" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1" fx:controller="application.view.AddEmployeController">
    <GridPane hgap="10" vgap="10">
        <Label text="Nom:" />
        <TextField fx:id="nomField" GridPane.columnIndex="1" />
        
        <Label text="Prénom:" GridPane.rowIndex="1" />
        <TextField fx:id="prenomField" GridPane.columnIndex="1" GridPane.rowIndex="1" />
        
        <Label text="Droits d'accès:" GridPane.rowIndex="2" />
        <RadioButton fx:id="userRadioButton" text="Guichetier" ToggleGroup="droitsAccessGroup" GridPane.columnIndex="1" GridPane.rowIndex="2" />
        <RadioButton fx:id="adminRadioButton" text="Chef d'agence" ToggleGroup="droitsAccessGroup" GridPane.columnIndex="1" GridPane.rowIndex="3" />
        
        <Label text="Login:" GridPane.rowIndex="4" />
        <TextField fx:id="loginField" GridPane.columnIndex="1" GridPane.rowIndex="4" />
        
        <Label text="Mot de passe:" GridPane.rowIndex="5" />
        <TextField fx:id="motPasseField" GridPane.columnIndex="1" GridPane.rowIndex="5" />
        
        <Label text="Numéro d'agence:" GridPane.rowIndex="6" />
        <TextField fx:id="idAgField" GridPane.columnIndex="1" GridPane.rowIndex="6" />
    </GridPane>
    <Button text="Ajouter" onAction="#handleAddEmploye" />
    <Button text="Annuler" onAction="#handleCancel" />
</VBox>
----

Le fichier FXML définit l'interface utilisateur pour ajouter un nouvel employé. Il inclut des champs de texte pour le nom, le prénom, le login, le mot de passe, et le numéro d'agence, ainsi que des boutons radio pour sélectionner les droits d'accès.

=== Modifications dans `Access_BD_Employe`

==== Ajout de Méthodes

[source,java]
----
public List<Employe> getAllEmployes() throws DataAccessException, DatabaseConnexionException {
    List<Employe> employes = new ArrayList<>();
    
    try {
        Connection con = LogToDatabase.getConnexion();
        String query = "SELECT * FROM Employe";
        PreparedStatement pst = con.prepareStatement(query);
        ResultSet rs = pst.executeQuery();

        while (rs.next()) {
            int idEmploye = rs.getInt("idEmploye");
            String nom = rs.getString("nom");
            String prenom = rs.getString("prenom");
            String droitsAccess = rs.getString("droitsAccess");
            String login = rs.getString("login");
            String motPasse = rs.getString("motPasse");
            int idAg = rs.getInt("idAg");

            Employe employe = new Employe(idEmploye, nom, prenom, droitsAccess, login, motPasse, idAg);
            employes.add(employe);
        }
        rs.close();
        pst.close();
    } catch (SQLException e) {
        throw new DataAccessException(Table.None, Order.INSERT, "Erreur lors de la récupération des employés", e);
    }

    return employes;
}

public void addEmploye(Employe employe) throws DataAccessException, DatabaseConnexionException {
    try {
        Connection con = LogToDatabase.getConnexion();
        String query = "INSERT INTO Employe (nom, prenom, droitsAccess, login, motPasse, idAg) VALUES (?, ?, ?, ?, ?, ?)";
        PreparedStatement pst = con.prepareStatement(query);

        pst.setString(1, employe.getNom());
        pst.setString(2, employe.getPrenom());
        pst.setString(3, employe.getDroitsAccess());
        pst.setString(4, employe.getLogin());
        pst.setString(5, employe.getMotPasse());
        pst.setInt(6, employe.getIdAg());

        pst.executeUpdate();
        pst.close();
    } catch (SQLException e) {
        throw new DataAccessException(Table.None, Order.INSERT, "Erreur lors de l'ajout de l'employé", e);
    }
}

public Employe getEmployeByLogin(String login) throws DataAccessException, DatabaseConnexionException {
    Employe employe = null;

    try {
        Connection con = LogToDatabase.getConnexion();
        String query = "SELECT * FROM Employe WHERE login = ?";
        PreparedStatement pst = con.prepareStatement(query);
        pst.setString(1, login);
        ResultSet rs = pst.executeQuery();

        if (rs.next()) {
            int idEmploye = rs.getInt("idEmploye");
            String nom = rs.getString("nom");
            String prenom = rs.getString("prenom");
            String droitsAccess = rs.getString("droitsAccess");
            String motPasse = rs.getString("motPasse");
            int idAg = rs.getInt("idAg");

            employe = new Employe(idEmploye, nom, prenom, droitsAccess, login, motPasse, idAg);
        }
        rs.close();
        pst.close();
    } catch (SQLException e) {
        throw new DataAccessException(Table.None, Order.INSERT, "Erreur lors de la récupération de l'employé par login", e);
    }

    return employe;
}
----

==== Description des Méthodes

- `getAllEmployes()`: Récupère tous les employés de la base de données.
- `addEmploye(Employe employe)`: Ajoute un nouvel employé à la base de données.
- `getEmployeByLogin(String login)`: Récupère un employé à partir de son login.

=== Conclusion

Les modifications apportées permettent de gérer l'ajout de nouveaux employés via une interface utilisateur dédiée. Le contrôleur associé gère la logique de validation et d'interaction avec la base de données, tandis que les méthodes ajoutées dans `Access_BD_Employe` facilitent les opérations CRUD nécessaires pour gérer les employés.



